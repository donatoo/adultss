// ==UserScript==
// @name         Vid Player ‚Äî Custom Subtitle DIV Renderer
// @namespace    http://tampermonkey.net/
// @version      2025-08-21
// @description  Clean player UI + custom subtitle container with full styling & timing control
// @author       You
// @match        https://player.vidpro.top/*
// @match        https://vidsrc.cc/*
// @match        https://vidrock.net/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=chatgpt.com
// @grant        none
// ==/UserScript==

(function () {
  'use strict';

  /******************************************************************
   * PHASE 1: Create the clean UI shell (your original layout)
   ******************************************************************/
  (function () {
    let check = setInterval(() => {
      let video = document.querySelector('video');
      if (!video) return;

      setTimeout(() => {
        if (!(video.seekable.length > 0)) {
          window.location.reload();
        }
      }, 4000);

      clearInterval(check);

      // Safe initial playback config
      video.volume = 0.5;
      video.muted = false;
      video.crossOrigin = "";

      // gentle autoplay
      video.addEventListener("loadedmetadata", () => {
        setTimeout(() => {
          video.play().catch(() => console.log("Autoplay blocked, user must click play"));
        }, 500);
      });

      // wipe all siblings, keep just the <video>
      [...video.parentElement.querySelectorAll('*')].forEach(el => {
        if (el !== video) el.style.display = 'none';
      });

      // container
      let container = document.createElement('div');
      container.id = 'player-container';
      container.style.position = 'relative';
      container.style.width = '100%';
      container.style.height = '100%';
      container.style.background = 'black';
      container.style.overflow = 'hidden';

      // video sizing
      video.style.width = '100%';
      video.style.height = '100%';
      video.style.objectFit = 'cover';
      video.style.position = 'absolute';
      video.style.top = '0';
      video.style.left = '0';
      container.appendChild(video);

      // loading badge for subtitles
      let subtitleLoading = document.createElement('div');
      subtitleLoading.id = 'subtitle-loading';
      subtitleLoading.style.display = 'none';
      subtitleLoading.textContent = 'Loading subtitles...';
      container.appendChild(subtitleLoading);

      // mount UI
      document.body.innerHTML = '';
      document.body.appendChild(container);

      // inject UI + styles (kept from your original)
      container.insertAdjacentHTML('beforeend', `
        <style>
          :fullscreen #player-container { display: flex; flex-direction: column; background: black; }
          :fullscreen video { width: 100%; height: 100%; object-fit: contain; }

          html, body { margin:0; padding:0; height:100%; background:black; font-family:sans-serif; }
          #player-container { position:relative; height:100%; background:black; overflow:hidden; }
          video { width:100%; height:100%; background:black; object-fit:contain; }

          button, select { background:#111; color:#fff; border:none; font-size:16px; cursor:pointer; }
          select#subtitlePicker, select#qualityPicker { background:#111; color:#fff; border:1px solid #555; padding:5px; border-radius:4px; width:40px; min-width:20px; max-width:40px; }
          #subtitlePicker { width:40px; min-width:20px; max-width:40px; }

          #subtitleModal {
            display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            background:#1c1c1c; color:white; padding:20px; border-radius:16px; z-index: 999999999999999999999999;
            width:300px; height:250px; overflow-y:auto; box-shadow:0 0 20px rgba(0,0,0,0.8);
            font-family:'Segoe UI', sans-serif; scrollbar-width:thin; scrollbar-color:#666 #1c1c1c;
          }
          #subtitleModal::-webkit-scrollbar { width:6px; }
          #subtitleModal::-webkit-scrollbar-thumb { background-color:#666; border-radius:4px; }
          #subtitleModal::-webkit-scrollbar-track { background-color:#1c1c1c; }
          #subtitleModal label { display:block; margin-bottom:5px; font-weight:500; color:#ccc; }
          #subtitleModal input, #subtitleModal select { width:100%; margin-bottom:10px; }
          #subtitleModal input[type="checkbox"] { width:auto; margin-right:6px; }
          #subtitleModal h3 { text-align:center; margin-bottom:20px; color:#fff; }
          #subtitleModal .font-style-options { display:flex; gap:10px; justify-content:space-between; margin-bottom:15px; }
          #subtitleModal .font-style-options label { font-size:14px; color:#ddd; }
          #closeModal { background:#e50914; color:white; border:none; padding:10px; width:100%; border-radius:8px; font-weight:bold; font-size:16px; cursor:pointer; transition:background .3s; }
          #closeModal:hover { background:#ff1f1f; }
          #resetDefaults { background:#444; color:white; border:none; padding:10px; width:100%; border-radius:8px; font-weight:bold; font-size:16px; cursor:pointer; margin-bottom:10px; transition:background .3s; }
          #resetDefaults:hover { background:#666; }

          .middle-controls {
            position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            display:flex; gap:20px; z-index:999999999; pointer-events:auto;
          }
          .middle-controls button {
            font-size:15px; background:rgba(0,0,0,0.6); color:white; border:none; border-radius:50%; padding:16px; z-index:999999999; cursor:pointer;
          }

          .controls {
            position:fixed; bottom:0; left:0; width:100%;
            background:rgba(0,0,0,0.6); display:flex; flex-direction:column; padding:8px; box-sizing:border-box; transition:opacity .3s; z-index:999;
          }
          .seekbar { width:100%; margin-bottom:8px; }
          .seekbar input[type="range"] { width:100%; }
          .control-bar { display:flex; justify-content:space-between; flex-wrap:wrap; align-items:center; }
          .control-group { display:flex; gap:8px; flex-wrap:wrap; }
          .control-bar button, .control-bar select { font-size:1rem; padding:6px 10px; min-width:36px; max-width:100%; box-sizing:border-box; }

          .volume-wrapper { display:flex; align-items:center; gap:6px; position:relative; }
          .volume-wrapper:hover #volume { display:block; }
          #volume { display:none; position:static; width:100px; }
          @media (max-width: 600px) { .control-bar button, .control-bar select { font-size:.9rem; padding:4px 8px; } }

          #subtitle-loading {
            position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
            background:rgba(0,0,0,0.7); color:white; padding:12px 18px; border-radius:6px; font-size:16px; font-weight:500;
            z-index:999999999999; opacity:0; pointer-events:none; transition:opacity .4s ease;
          }
          #subtitle-loading.show { opacity:1; }
        </style>

        <!-- Subtitle iframe modal -->
        <div id="subtitleIframeModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); width:90%; max-width:600px; height:70%; background:#000; border:2px solid #333; border-radius:10px; overflow:hidden;">
          <iframe id="subtitleIframe" src="" frameborder="0" style="width:100%; height:100%;"></iframe>
        </div>

        <div class="middle-controls">
          <button id="rewind">‚è™</button>
          <button id="playpause">‚ñ∂Ô∏è</button>
          <button id="forward">‚è©</button>
        </div>

        <div class="controls">
          <div class="seekbar-wrapper" style="display:flex; flex-direction:column; align-items:flex-start;">
            <div id="timeDisplay" style="color:white; font-size:14px; padding-left:6px; padding-bottom:4px;">
              <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
            </div>
            <div class="seekbar" style="width:100%;">
              <input type="range" id="seek" min="0" value="0" step="0.1">
            </div>
          </div>

          <div class="control-bar">
            <div class="control-group">
              <button id="pipBtn">üì∫</button>
              <button id="download">‚¨áÔ∏è</button>
              <div class="volume-wrapper">
                <button id="volume-icon">üîà</button>
                <input type="range" id="volume" min="0" max="1" step="0.01" title="Volume">
              </div>
            </div>
            <div class="control-group">
              <select id="subtitlePicker"></select>
              <select id="qualityPicker" title="Video Quality"></select>
              <button id="customizeBtn">‚öôÔ∏è</button>
              <button id="fullscreenBtn">üî≥</button>
            </div>
          </div>
        </div>

        <div id="overlay" style="display:none; position:absolute; inset:0; background:rgba(0,0,0,.5);"></div>

        <div id="subtitleModal">
          <h3>Subtitle Settings</h3>

          <label>Font Size</label>
          <input type="number" id="sub-fontsize" min="10" max="72">

          <label>Font Color</label>
          <input type="color" id="sub-color">

          <label>Background Opacity</label>
          <input type="range" id="sub-bgopacity" min="0" max="1" step="0.1">

          <label>Background Color</label>
          <input type="color" id="sub-bgcolor">

          <label>Position</label>
          <select id="sub-position">
            <option value="bottom">Bottom</option>
            <option value="top">Top</option>
          </select>

          <label>Offset (px)</label>
          <input type="range" id="sub-offset" min="-200" max="200" step="0.5">

          <label>Font Family</label>
          <select id="sub-fontfamily">
            <option value="sans-serif">Sans Serif</option>
            <option value="serif">Serif</option>
            <option value="monospace">Monospace</option>
            <option value="Arial">Arial</option>
            <option value="Georgia">Georgia</option>
            <option value="Tahoma">Tahoma</option>
            <option value="Verdana">Verdana</option>
          </select>

          <label>Font Style</label>
          <div class="font-style-options">
            <label><input type="checkbox" id="sub-bold"> Bold</label>
            <label><input type="checkbox" id="sub-italic"> Italic</label>
            <label><input type="checkbox" id="sub-underline"> Underline</label>
          </div>

          <button id="resetDefaults">Reset</button>
          <button id="closeModal">Close</button>
        </div>

        <style id="cue-style"></style>
      `);

    }, 10);
  })();

  /******************************************************************
   * PHASE 2: Wire controls + CUSTOM SUBTITLE ENGINE
   ******************************************************************/
  let check = setInterval(() => {
    const video = document.querySelector('video');
    if (!video) return;
    clearInterval(check);

    // Grab controls
    const currentTimeEl = document.getElementById("currentTime");
    const durationEl = document.getElementById("duration");
    const playPauseBtn = document.getElementById("playpause");
    const rewindBtn = document.getElementById("rewind");
    const forwardBtn = document.getElementById("forward");
    const seekBar = document.getElementById("seek");
    const subtitlePicker = document.getElementById("subtitlePicker");
    const customizeBtn = document.getElementById("customizeBtn");
    const subtitleModal = document.getElementById("subtitleModal");
    const overlay = document.getElementById("overlay");

    const fontSizeInput = document.getElementById('sub-fontsize');
    const colorInput = document.getElementById('sub-color');
    const positionSelect = document.getElementById('sub-position');
    const bgOpacityInput = document.getElementById('sub-bgopacity');
    const bgColorInput = document.getElementById('sub-bgcolor');
    const offsetInput = document.getElementById('sub-offset');
    const fontFamilySelect = document.getElementById('sub-fontfamily');
    const boldCheckbox = document.getElementById('sub-bold');
    const italicCheckbox = document.getElementById('sub-italic');
    const underlineCheckbox = document.getElementById('sub-underline');
    const closeModal = document.getElementById('closeModal');

    const pipBtn = document.getElementById("pipBtn");
    const download = document.getElementById("download");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const volumeSlider = document.getElementById("volume");
    const controls = document.querySelector('.controls');
    const volumeIcon = document.getElementById("volume-icon");
    const midcontrols = document.querySelector('.middle-controls');
    const loadingEl = document.getElementById("subtitle-loading");








    /*************** SETTINGS ***************/
    let settings = JSON.parse(localStorage.getItem('subtitleSettings') || '{}');
    const defaultSettings = {
      fontSize: 20,
      color: '#ffffff',
      position: 'bottom',
      bgOpacity: 0.5,
      bgColor: '#000000',
      offset: 0, // px
      fontFamily: 'monospace',
      bold: true,
      italic: false,
      underline: false,
      timingOffset: 0 // seconds (+ shows later, - shows earlier)
    };
    settings = { ...defaultSettings, ...settings };

    /*************** CUSTOM SUBTITLE ENGINE ***************/
    let subtitleOffset = 0;         // seconds
    let subsDisabled = false;
    let currentSubtitleSet = [];    // currently parsed cues [{startTime, endTime, text}]
    let pickerIndexToVttText = {};  // map picker index => raw VTT text
    let rafId = null;

    // Build/ensure subtitle container
    function ensureSubtitleContainer() {
      let container = document.getElementById("custom-subtitles");
      if (!container) {
        container = document.createElement("div");
        container.id = "custom-subtitles";
        Object.assign(container.style, {
          position: "absolute",
          bottom: "8%",
          left: "50%",
          transform: "translateX(-50%)",
          display: "inline-block",
          maxWidth: "90%",
          textAlign: "center",
          color: "#fff",
          textShadow: "0 0 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.6)",
          fontSize: "2.2vh",
          fontFamily: "Arial, Helvetica, sans-serif",
          fontWeight: "500",
          pointerEvents: "none",
          zIndex: 35,
          lineHeight: "1.4",
          padding: "0.2em 0.4em",
          boxSizing: "border-box",
          wordWrap: "break-word",
          whiteSpace: "pre-wrap"
        });
        video.parentElement.style.position = "relative";
        video.parentElement.appendChild(container);
      }
      return container;
    }

    function hexToRgba(hex, opacity) {
      const bigint = parseInt(hex.replace("#", ""), 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }

    // Apply style settings to the custom container
    function applyStyleSettings() {
      const container = ensureSubtitleContainer();
      container.style.fontSize = (settings.fontSize || 20) + "px";
      container.style.color = settings.color || "#fff";
      container.style.background = hexToRgba(settings.bgColor || "#000000", settings.bgOpacity ?? 0.5);
      container.style.fontFamily = settings.fontFamily || "sans-serif";
      container.style.fontWeight = settings.bold ? "bold" : "normal";
      container.style.fontStyle = settings.italic ? "italic" : "normal";
      container.style.textDecoration = settings.underline ? "underline" : "none";

      // Position (top/bottom) + offset (px)
      if (settings.position === "top") {
        container.style.top = "8%";
        container.style.bottom = "auto";
      } else {
        container.style.bottom = "8%";
        container.style.top = "auto";
      }
      // pixel offset (positive moves text up if bottom, or down if top)
      const px = parseFloat(settings.offset) || 0;
      if (settings.position === "top") {
        container.style.top = `calc(8% + ${px}px)`;
      } else {
        container.style.bottom = `calc(8% + ${px}px)`;
      }
    }

    // Time utilities + parser
    function toSeconds(timeStr) {
      // supports mm:ss.mmm or hh:mm:ss.mmm
      const parts = timeStr.split(":");
      let h = 0, m = 0, s = 0, ms = 0;
      if (parts.length === 3) {
        h = parseInt(parts[0]);
        m = parseInt(parts[1]);
        [s, ms] = parts[2].split(".");
      } else if (parts.length === 2) {
        m = parseInt(parts[0]);
        [s, ms] = parts[1].split(".");
      }
      return h * 3600 + m * 60 + parseInt(s) + (parseInt(ms) || 0) / 1000;
    }

    function parseVTT(vttText) {
      const cues = [];
      const lines = vttText.split(/\r?\n/);
      let cue = null;
      for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const line = raw.trim();
        if (!line || line.startsWith("WEBVTT")) continue;

        const match = line.match(/^((?:\d{2}:)?\d{2}:\d{2}\.\d{3})\s*-->\s*((?:\d{2}:)?\d{2}:\d{2}\.\d{3})/);
        if (match) {
          if (cue) cues.push(cue);
          cue = { startTime: toSeconds(match[1]), endTime: toSeconds(match[2]), text: "" };
          continue;
        }

        if (cue) {
          cue.text += (cue.text ? "\n" : "") + raw; // keep original line breaks (no trim)
          if (!lines[i + 1] || !lines[i + 1].trim()) {
            cues.push(cue);
            cue = null;
          }
        }
      }
      if (cue) cues.push(cue);
      return cues;
    }

    function srtToVtt(srt) {
      srt = srt.replace(/^\uFEFF/, '');
      srt = srt.replace(/^\d+\s*$/gm, '');
      srt = srt.replace(/(\d{2}:\d{2}:\d{2}),(\d{3})/g, '$1.$2');
      return 'WEBVTT\n\n' + srt.trim();
    }

    // Render loop
    function startRenderLoop() {
      cancelRenderLoop();
      const container = ensureSubtitleContainer();
      function frame() {
        const t = (video.currentTime || 0) + (settings.timingOffset || 0) + subtitleOffset;
        if (!subsDisabled && currentSubtitleSet.length) {
          // Binary search could be added; filter is fine for now
          const active = currentSubtitleSet.filter(c => t >= c.startTime && t <= c.endTime);
          if (active.length) {
            container.innerHTML = active.map(c => c.text.replace(/\\n/g, "<br>")).join("<br>");
            container.style.display = "inline-block";
          } else {
            container.innerHTML = "";
            container.style.display = "none";
          }
        } else {
          container.innerHTML = "";
          container.style.display = "none";
        }
        rafId = requestAnimationFrame(frame);
      }
      rafId = requestAnimationFrame(frame);
    }

    function cancelRenderLoop() {
      if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    }

    // Apply a new VTT to the engine
    function applySubtitle(vttText, label = "") {
      subsDisabled = false;
      currentSubtitleSet = parseVTT(vttText);
      startRenderLoop();
      // Optional: notify
      // alert("‚úÖ Subtitle applied: " + (label || "Loaded"));
    }

    // Helpers: loading badge
    function showSubtitleLoading() {
      loadingEl.style.display = "block";
      requestAnimationFrame(() => loadingEl.classList.add("show"));
    }
    function hideSubtitleLoading() {
      loadingEl.classList.remove("show");
      setTimeout(() => loadingEl.style.display = "none", 400);
    }

    // Populate picker **without** creating native <track> (we handle rendering)
    function fillSubtitlePicker(subtitles) {
      subtitlePicker.innerHTML = '';
      const off = document.createElement("option");
      off.value = 'off';
      off.textContent = 'Off';
      subtitlePicker.appendChild(off);

      pickerIndexToVttText = {};
      subtitles.forEach((sub, idx) => {
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = sub.label || `Track ${idx + 1}`;
        subtitlePicker.appendChild(opt);
        pickerIndexToVttText[String(idx)] = sub; // store object (may have vttText or url)
      });

      // default to Off
      subsDisabled = true;
      cancelRenderLoop();
      ensureSubtitleContainer().style.display = "none";
    }

    // Your existing subtitle page scraper -> returns [{label, lang, url:data:text/vtt...}]
    async function fetchAndPrepareSubtitles(htmlPages) {
      const allSubtitles = await Promise.all(
        htmlPages.map(async (url) => {
          try {
            const html = await fetch(url).then(res => res.text());
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const rows = doc.querySelectorAll("table tbody tr");

            const pageSubs = await Promise.all(
              Array.from(rows).map(async (row) => {
                const cells = row.querySelectorAll("td");
                if (cells.length < 4) return null;
                const label = cells[0].innerText.trim();
                const link = cells[3].querySelector("a");
                const subtitleUrl = link?.href;
                if (!subtitleUrl) return null;

                try {
                  const buffer = await fetch(subtitleUrl).then(res => res.arrayBuffer());
                  const decoder = new TextDecoder("utf-8");
                  let text = decoder.decode(buffer);
                  let vtt = text.startsWith("WEBVTT") ? text : srtToVtt(text);
                  return {
                    label: label || "Unknown",
                    lang: "en",
                    // Store as raw text for our engine
                    vttText: vtt
                  };
                } catch {
                  return null;
                }
              })
            );

            return pageSubs.filter(Boolean);
          } catch {
            return [];
          }
        })
      );
      return allSubtitles.flat();
    }

    /*************** UI events ***************/
    // Settings modal open
    customizeBtn.addEventListener("click", () => {
      fontSizeInput.value = settings.fontSize;
      colorInput.value = settings.color;
      positionSelect.value = settings.position;
      bgOpacityInput.value = settings.bgOpacity;
      bgColorInput.value = settings.bgColor;
      offsetInput.value = settings.offset;
      fontFamilySelect.value = settings.fontFamily;
      boldCheckbox.checked = settings.bold;
      italicCheckbox.checked = settings.italic;
      underlineCheckbox.checked = settings.underline;
      overlay.style.display = "block";
      subtitleModal.style.display = "block";
    });

    // Live preview while sliding/changing
    [fontSizeInput, colorInput, positionSelect, bgOpacityInput, bgColorInput, offsetInput, fontFamilySelect, boldCheckbox, italicCheckbox, underlineCheckbox].forEach(input => {
      input.addEventListener("input", () => {
        settings.fontSize = parseInt(fontSizeInput.value, 10) || defaultSettings.fontSize;
        settings.color = colorInput.value;
        settings.position = positionSelect.value;
        settings.bgOpacity = parseFloat(bgOpacityInput.value);
        settings.bgColor = bgColorInput.value;
        settings.offset = parseFloat(offsetInput.value);
        settings.fontFamily = fontFamilySelect.value;
        settings.bold = !!boldCheckbox.checked;
        settings.italic = !!italicCheckbox.checked;
        settings.underline = !!underlineCheckbox.checked;
        applyStyleSettings();
      });
    });

    // Reset defaults
    document.getElementById("resetDefaults").addEventListener("click", () => {
      settings = { ...defaultSettings };
      fontSizeInput.value = settings.fontSize;
      colorInput.value = settings.color;
      bgOpacityInput.value = settings.bgOpacity;
      bgColorInput.value = settings.bgColor;
      positionSelect.value = settings.position;
      offsetInput.value = settings.offset;
      fontFamilySelect.value = settings.fontFamily;
      boldCheckbox.checked = settings.bold;
      italicCheckbox.checked = settings.italic;
      underlineCheckbox.checked = settings.underline;
      applyStyleSettings();
      localStorage.setItem("subtitleSettings", JSON.stringify(settings));
    });

    // Close modal & persist
    closeModal.onclick = () => {
      settings.fontSize = parseInt(fontSizeInput.value, 10) || defaultSettings.fontSize;
      settings.color = colorInput.value;
      settings.position = positionSelect.value;
      settings.bgOpacity = parseFloat(bgOpacityInput.value);
      settings.bgColor = bgColorInput.value;
      settings.offset = parseFloat(offsetInput.value);
      settings.fontFamily = fontFamilySelect.value;
      settings.bold = !!boldCheckbox.checked;
      settings.italic = !!italicCheckbox.checked;
      settings.underline = !!underlineCheckbox.checked;
      localStorage.setItem('subtitleSettings', JSON.stringify(settings));
      applyStyleSettings();
      overlay.style.display = "none";
      subtitleModal.style.display = "none";
    };

    // Initial style apply
    applyStyleSettings();

    // Picker change -> load/apply VTT
    subtitlePicker.onchange = async () => {
      const val = subtitlePicker.value;
      if (val === 'off') {
        subsDisabled = true;
        cancelRenderLoop();
        ensureSubtitleContainer().style.display = "none";
        return;
      }
      const entry = pickerIndexToVttText[val];
      if (!entry) return;

      showSubtitleLoading();
      try {
        let vtt = entry.vttText;
        if (!vtt && entry.url) {
          // Fallback if source is a URL (e.g., data:text/vtt or remote)
          const text = await fetch(entry.url).then(r => r.text());
          vtt = text.startsWith("WEBVTT") ? text : srtToVtt(text);
        }
        applySubtitle(vtt, entry.label);
      } finally {
        hideSubtitleLoading();
      }
    };

    // External messaging API (compatible with your snippet)
    window.parent.postMessage("ready", "*");
    window.addEventListener("message", async (event) => {
      const data = event.data;
      if (!data){
window.parent.postMessage("ready", "*");
 return;
}

      // Batch from pages: "id:https://page1,..."
      if (typeof data === "string" && data.startsWith("id:")) {
        const url = data.split("id:")[1];
        if (typeof url === "string" && url.includes("http")) {
          const urls = url.split(",").map(u => u.trim());
          document.getElementById("subtitleIframeModal").style.display = "none";
          showSubtitleLoading();
          try {
            const subtitles = await fetchAndPrepareSubtitles(urls);
            fillSubtitlePicker(subtitles);
            hideSubtitleLoading();
          } catch {
            hideSubtitleLoading();
          }
        }
      }else{
       window.parent.postMessage("ready", "*");
}

      // Direct URL to .srt/.vtt
      if (data.type === "subtitle-url") {
        subsDisabled = false;
        showSubtitleLoading();
        try {
          const buffer = await fetch(data.url).then((res) => res.arrayBuffer());
          const decoder = new TextDecoder("utf-8");
          const text = decoder.decode(buffer);
          const vtt = text.startsWith("WEBVTT") ? text : srtToVtt(text);
          // Fill picker with one temp item for UX
          fillSubtitlePicker([{ label: data.label || "Remote", vttText: vtt }]);
          subtitlePicker.value = "0";
          applySubtitle(vtt, data.label || "Remote");
        } catch (err) {
          alert("Error fetching subtitle: " + err);
        } finally {
          hideSubtitleLoading();
        }
      }

      // Raw VTT data (already combined)
      if (data.type === "subtitle-data") {
        const vtt = data.data.startsWith("WEBVTT") ? data.data : srtToVtt(data.data);
        fillSubtitlePicker([{ label: data.label || "Custom", vttText: vtt }]);
        subtitlePicker.value = "0";
        applySubtitle(vtt, data.label || "Custom");
      }

      if (data.type === "disable-subtitles") {
        subsDisabled = true;
        cancelRenderLoop();
        ensureSubtitleContainer().style.display = "none";
      }

      // Fine-grained live settings from outside
      if (data.type === "subtitleSettings" && data.settings) {
        const s = data.settings;
        if (typeof s.fontSize === "number") settings.fontSize = s.fontSize;
        if (typeof s.color === "string") settings.color = s.color;
        if (typeof s.bgColor === "string") settings.bgColor = s.bgColor;
        if (typeof s.bgOpacity === "number") settings.bgOpacity = s.bgOpacity;
        if (typeof s.bold === "boolean") settings.bold = s.bold;
        if (typeof s.italic === "boolean") settings.italic = s.italic;
        if (typeof s.underline === "boolean") settings.underline = s.underline;

        if (s.position === "top" || s.position === "bottom") settings.position = s.position;

        // If given a "verticalOffset" (percentage-like), translate to pixels by using video height
        if (typeof s.verticalOffset === "number") {
          // We map [0..100] to a percentage of video height; convert to px
          const vh = video.getBoundingClientRect().height || 0;
          settings.offset = Math.round((s.verticalOffset / 100) * vh - (0.08 * vh)); // 8% baseline already applied
        }

        if (typeof s.timingOffset === "number") subtitleOffset = s.timingOffset;

        applyStyleSettings();
      }
    });

    /*************** Player wiring (time/seek/volume/fullscreen) ***************/
    function formatTime(seconds) {
      seconds = Math.max(0, seconds || 0);
      const min = Math.floor(seconds / 60);
      const sec = Math.floor(seconds % 60);
      return min + ":" + (sec < 10 ? "0" + sec : sec);
    }

    video.addEventListener("loadedmetadata", () => {
      if (video.duration && isFinite(video.duration) && video.duration > 0) {
        durationEl.textContent = formatTime(video.duration);
        seekBar.max = video.duration;
      } else if (video.seekable && video.seekable.length > 0) {
        const end = video.seekable.end(video.seekable.length - 1);
        durationEl.textContent = formatTime(end);
        seekBar.max = end;
      }
    });

    video.addEventListener("timeupdate", () => {
      currentTimeEl.textContent = formatTime(video.currentTime);
      seekBar.value = video.currentTime;
    });

    playPauseBtn.onclick = () => {
      if (video.paused) {
        video.play();
        playPauseBtn.textContent = "‚è∏Ô∏è";
      } else {
        video.pause();
        playPauseBtn.textContent = "‚ñ∂Ô∏è";
      }
    };
    rewindBtn.onclick = () => video.currentTime = Math.max(0, video.currentTime - 10);
    forwardBtn.onclick = () => video.currentTime = Math.min((+seekBar.max || video.duration || 1e9), video.currentTime + 10);

    seekBar.addEventListener("input", () => {
      video.currentTime = parseFloat(seekBar.value);
    });

    video.addEventListener("play", () => {
      playPauseBtn.textContent = "‚è∏Ô∏è";
    });

    video.addEventListener("click", () => {
      const controlsVisible = getComputedStyle(controls).opacity === "1";
      const midVisible = getComputedStyle(midcontrols).opacity === "1";
      controls.style.opacity = controlsVisible ? "0" : "1";
      midcontrols.style.opacity = midVisible ? "0" : "1";
    });

    function updateVolumeIcon() {
      if (video.muted || video.volume === 0) {
        volumeIcon.textContent = 'üîá';
      } else if (video.volume < 0.5) {
        volumeIcon.textContent = 'üîâ';
      } else {
        volumeIcon.textContent = 'üîä';
      }
    }
    video.addEventListener("volumechange", () => {
      volumeSlider.value = video.volume;
      updateVolumeIcon();
    });
    volumeSlider.addEventListener('input', () => {
      video.volume = parseFloat(volumeSlider.value);
      video.muted = video.volume === 0;
      updateVolumeIcon();
    });
    volumeIcon.addEventListener('click', () => {
      video.muted = !video.muted;
      if (!video.muted && video.volume === 0) {
        video.volume = 0.5;
        volumeSlider.value = 0.5;
      }
      updateVolumeIcon();
    });

    fullscreenBtn.addEventListener("click", async () => {
      const container = document.getElementById("player-container");
      if (!document.fullscreenElement) {
        if (container.requestFullscreen) await container.requestFullscreen();
        else if (container.webkitRequestFullscreen) await container.webkitRequestFullscreen();
        if (screen.orientation && screen.orientation.lock) {
          try { await screen.orientation.lock("landscape"); } catch (_) {}
        }
      } else {
        if (document.exitFullscreen) await document.exitFullscreen();
        else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
        if (screen.orientation && screen.orientation.unlock) screen.orientation.unlock();
      }
    });




    setTimeout(() => {
      durationEl.textContent = formatTime(video.duration);
      seekBar.max = video.duration || seekBar.max || 0;
    }, 2000);

    // Initialize picker default (Off)
    fillSubtitlePicker([]);



  // ------------- Utilities -------------
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const toAbs = (base, rel) => {
    try {
      return new URL(rel, base).toString();
    } catch { return rel; }
  };
  const humanMB = (bytes) => (bytes / (1024 * 1024)).toFixed(1) + " MB";

  // ------------- Global state -------------
  let ui = {};
  let abortAll = false;
  let activeControllers = [];
  let lastPlaylistUrl = null; // sniffed .m3u8 (for blob/MSE players)

  // ------------- Sniff .m3u8 via fetch/XHR (for blob:MSE cases) -------------
  (function hookNetwork() {
    const origFetch = window.fetch;
    window.fetch = function (...args) {
      try {
        const url = String(args[0]);
        if (url.includes(".m3u8")) lastPlaylistUrl = url;
      } catch {}
      return origFetch.apply(this, args);
    };

    const origOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function (method, url) {
      try {
        if (String(url).includes(".m3u8")) lastPlaylistUrl = String(url);
      } catch {}
      return origOpen.apply(this, arguments);
    };
  })();

  // ------------- UI (button + overlays) -------------
  function ensureUI(videoEl) {
    if (ui.initialized) return;
    ui.initialized = true;

    // Download button
    const btn = document.createElement("button");
    btn.textContent = "‚¨á Download";
    Object.assign(btn.style, {
      position: "fixed",
      bottom: "20px",
      left: "20px",
      zIndex: 100000,
      padding: "10px 14px",
      background: "#2196f3",
      color: "#fff",
      border: "none",
      borderRadius: "10px",
      cursor: "pointer",
      boxShadow: "0 4px 14px rgba(0,0,0,.2)",
      fontWeight: "600"
    });
    //document.body.appendChild(btn);

    // Fullscreen overlay (status/progress)
    const overlay = document.createElement("div");
    Object.assign(overlay.style, {
      position: "fixed", inset: "0",
      background: "rgba(0,0,0,0.8)",
      display: "none",
      alignItems: "center", justifyContent: "center",
      zIndex: 100001, color: "#fff",
      fontFamily: "system-ui, sans-serif", flexDirection: "column", gap: "12px"
    });
    const status = document.createElement("div");
    status.textContent = "Preparing‚Ä¶";
    status.style.fontSize = "18px";
    const progress = document.createElement("div");
    progress.textContent = "";
    progress.style.opacity = "0.85";
    const cancel = document.createElement("button");
    cancel.textContent = "Cancel";
    Object.assign(cancel.style, {
      padding: "8px 14px", border: "none",
      background: "#f44336", color: "#fff",
      borderRadius: "8px", cursor: "pointer"
    });
    overlay.append(status, progress, cancel);
    document.body.appendChild(overlay);

    // Quality chooser overlay
    const chooser = document.createElement("div");
    Object.assign(chooser.style, {
      position: "fixed", inset: "0",
      background: "rgba(0,0,0,0.8)",
      display: "none",
      alignItems: "center", justifyContent: "center",
      zIndex: 100002, color: "#111",
      fontFamily: "system-ui, sans-serif",
    });
    const dialog = document.createElement("div");
    Object.assign(dialog.style, {
      background: "#fff", padding: "20px", borderRadius: "14px",
      minWidth: "280px", maxWidth: "90vw", boxShadow: "0 10px 30px rgba(0,0,0,.25)",
      textAlign: "center"
    });
    const title = document.createElement("div");
    title.textContent = "Select Quality";
    title.style.fontSize = "18px";
    title.style.fontWeight = "700";
    title.style.marginBottom = "10px";
    const list = document.createElement("div");
    list.style.display = "grid";
    list.style.gridTemplateColumns = "1fr";
    list.style.gap = "8px";
    const cancelQ = document.createElement("button");
    cancelQ.textContent = "Cancel";
    Object.assign(cancelQ.style, {
      marginTop: "10px",
      padding: "8px 14px", border: "none",
      background: "#eee", borderRadius: "8px", cursor: "pointer"
    });
    dialog.append(title, list, cancelQ);
    chooser.appendChild(dialog);
    document.body.appendChild(chooser);

    ui = { ...ui, btn, overlay, status, progress, cancel, chooser, list };

    cancel.onclick = () => doAbort();
    cancelQ.onclick = () => (ui.chooser.style.display = "none");

  
  }

  function doAbort() {
    abortAll = true;
    ui.overlay.style.display = "none";
    ui.chooser.style.display = "none";
    // Abort any in-flight requests
    activeControllers.forEach(c => { try { c.abort(); } catch {} });
    activeControllers = [];
  }

  // ------------- Parsing playlists -------------
  function parseMasterPlaylist(text, baseUrl) {
    // Returns array of variants: { url, bandwidth, resolution }
    const variants = [];
    const re = /#EXT-X-STREAM-INF:([^\n]+)\n([^\n#][^\n]*)/g;
    let m;
    while ((m = re.exec(text)) !== null) {
      const attrs = m[1];
      let url = m[2].trim();
      if (!/^https?:/.test(url)) url = toAbs(baseUrl, url);
      const bw = /BANDWIDTH=(\d+)/.exec(attrs)?.[1] || "";
      const res = /RESOLUTION=(\d+x\d+)/.exec(attrs)?.[1] || "";
      variants.push({ url, bandwidth: Number(bw || 0), resolution: res });
    }
    return variants;
  }

  function parseMediaPlaylist(text, baseUrl) {
    // Detect init segment for fMP4
    const initMatch = /#EXT-X-MAP:URI="([^"]+)"/.exec(text);
    const initUrl = initMatch ? toAbs(baseUrl, initMatch[1]) : null;

    // Byterange (basic detect)
    const hasByterange = /#EXT-X-BYTERANGE:/.test(text);

    // Collect segments (lines not starting with '#')
    const segs = [];
    const lines = text.split(/\r?\n/);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line || line.startsWith("#")) continue;
      let url = line;
      if (!/^https?:/.test(url)) url = toAbs(baseUrl, url);
      segs.push({ url });
    }
    return { initUrl, segments: segs, hasByterange };
  }

  // ------------- Core flow -------------
  async function startDownloadFlow(video) {
    try {
      ui.status.textContent = "Analyzing video source‚Ä¶";
      ui.progress.textContent = "";
      ui.overlay.style.display = "flex";

      // Prefer video.currentSrc; fallback to last sniffed .m3u8 if src is blob:
      let src = video.currentSrc || video.src || "";
      if ((!src || src.startsWith("blob:")) && lastPlaylistUrl) {
        src = lastPlaylistUrl;
      }

      if (!src) {
        ui.status.textContent = "No usable source found (might be DRM or fully opaque MSE).";
        return;
      }

      if (/\.(mp4|webm)(\?|#|$)/i.test(src)) {
        await downloadDirect(src);
        ui.status.textContent = "Done!";
        setTimeout(() => ui.overlay.style.display = "none", 1200);
        return;
      }

      if (src.includes(".m3u8")) {
        await downloadHLS(src);
        return;
      }

      ui.status.textContent = "Unknown source type (not mp4/webm/m3u8).";
    } catch (err) {
      ui.status.textContent = "Error: " + err.message;
    }
  }

  // ------------- Direct file download -------------
  async function downloadDirect(url) {
    const controller = new AbortController();
    activeControllers.push(controller);

    ui.status.textContent = "Downloading file‚Ä¶";
    const resp = await fetch(url, { signal: controller.signal });
    if (!resp.ok || !resp.body) throw new Error("Network error: " + resp.status);

    const reader = resp.body.getReader();
    let received = 0;
    const chunks = [];
    while (true) {
      if (abortAll) throw new Error("Canceled");
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      received += value.length;
      ui.progress.textContent = `Received ${humanMB(received)}`;
    }
    const ext = /\.webm(\?|#|$)/i.test(url) ? "webm" : "mp4";
    saveBlob(new Blob(chunks, { type: `video/${ext}` }), `video.${ext}`);
  }

  // ------------- HLS download -------------
  async function downloadHLS(masterUrl) {
    ui.status.textContent = "Fetching playlist‚Ä¶";
    const masterTxt = await fetchText(masterUrl);

    // Master or media?
    const variants = parseMasterPlaylist(masterTxt, masterUrl);
    let mediaUrl = masterUrl;

    if (variants.length > 0) {
      // Show chooser
      ui.chooser.style.display = "flex";
      ui.list.innerHTML = "";

      // Sort by bandwidth desc
      variants.sort((a, b) => (b.bandwidth - a.bandwidth));

      const makeBtn = (label, url) => {
        const b = document.createElement("button");
        b.textContent = label;
        Object.assign(b.style, {
          padding: "8px 12px", border: "1px solid #ddd",
          borderRadius: "10px", cursor: "pointer", background: "#f8f8f8"
        });
        b.onclick = async () => {
          ui.chooser.style.display = "none";
          await handleMediaPlaylist(url);
        };
        return b;
      };

      variants.forEach(v => {
        const label = `${v.resolution || "Unknown"}  ‚Ä¢  ${v.bandwidth ? Math.round(v.bandwidth/1000) + " kbps" : ""}`;
        ui.list.appendChild(makeBtn(label, v.url));
      });

      // Also add "Auto (first)" for convenience
      const autoBtn = makeBtn("Auto (best)", variants[0].url);
      autoBtn.style.background = "#e9f5ff";
      autoBtn.style.borderColor = "#bfe3ff";
      ui.list.insertBefore(autoBtn, ui.list.firstChild);
      return;
    } else {
      await handleMediaPlaylist(mediaUrl);
    }
  }

  async function handleMediaPlaylist(mediaUrl) {
    ui.overlay.style.display = "flex";
    ui.status.textContent = "Fetching media playlist‚Ä¶";
    const text = await fetchText(mediaUrl);
    const base = mediaUrl.substring(0, mediaUrl.lastIndexOf("/") + 1);
    const { initUrl, segments, hasByterange } = parseMediaPlaylist(text, base);

    if (hasByterange) {
      ui.status.textContent = "This stream uses BYTERANGE segments (not supported here). Try yt-dlp.";
      return;
    }
    if (!segments.length) {
      ui.status.textContent = "No segments found.";
      return;
    }

    // Determine container type by first segment extension
    const firstUrl = segments[0].url;
    const isTS = /\.ts(\?|#|$)/i.test(firstUrl);
    const isFmp4 = /\.m4s(\?|#|$)/i.test(firstUrl) || /\.mp4(\?|#|$)/i.test(firstUrl) || !!initUrl;

    // Download
    let totalBytes = 0;
    const chunks = [];

    if (isFmp4 && initUrl) {
      ui.status.textContent = "Downloading init segment‚Ä¶";
      const initBuf = await fetchArrayBuffer(initUrl);
      chunks.push(new Uint8Array(initBuf));
      totalBytes += initBuf.byteLength;
      ui.progress.textContent = `Init: ${humanMB(totalBytes)}`;
    }

    ui.status.textContent = `Downloading segments (0 / ${segments.length})‚Ä¶`;
    for (let i = 0; i < segments.length; i++) {
      if (abortAll) throw new Error("Canceled");
      const seg = segments[i];
      const buf = await fetchArrayBuffer(seg.url);
      chunks.push(new Uint8Array(buf));
      totalBytes += buf.byteLength;
      ui.status.textContent = `Downloading segments (${i+1} / ${segments.length})‚Ä¶`;
      ui.progress.textContent = `${humanMB(totalBytes)}`;
    }

    // Save
    if (isTS) {
      saveBlob(new Blob(chunks, { type: "video/mp2t" }), "video.ts");
    } else if (isFmp4) {
      saveBlob(new Blob(chunks, { type: "video/mp4" }), "video.mp4");
    } else {
      // Fallback
      saveBlob(new Blob(chunks), "video.bin");
    }
    ui.status.textContent = "Done!";
    setTimeout(() => (ui.overlay.style.display = "none"), 1200);
  }

  // ------------- Fetch helpers with Abort -------------
  async function fetchText(url) {
    const controller = new AbortController();
    activeControllers.push(controller);
    const resp = await fetch(url, { signal: controller.signal });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.text();
  }

  async function fetchArrayBuffer(url) {
    const controller = new AbortController();
    activeControllers.push(controller);
    const resp = await fetch(url, { signal: controller.signal });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.arrayBuffer();
  }

  function saveBlob(blob, filename) {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 2000);
  }

  // ------------- Watch for dynamic video-------------
  const findVideo = () => document.querySelector("video");

 const Downloadbtn = document.getElementById("download");


  Downloadbtn.onclick = async () => {
      const video = document.querySelector("video");
      abortAll = false;
      if (!video) {
        alert("No video element found yet.");
        return;
      }
      if (video) ensureUI(video);
      await startDownloadFlow(video);
    };


 


  }, 2500);





})();
